<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GooseGang17 - Twitch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none; /* Prevent text selection while dragging */
            /* Default styles for modern look */
            background-color: #171717;
            background-image: none;
            color: #ffffff;
        }

        body.retro-mode {
            font-family: 'Verdana', sans-serif;
            background-color: #C0C0C0; /* Classic Windows 95 grey */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath fill='%239E9E9E' d='M0 0h8v8H0V0zm8 8h8v8H8V8z'/%3E%3C/svg%3E");
            color: #000000;
        }

        /* Style for each animated background image */
        .bg-image {
            position: absolute;
            width: 250px;
            height: auto;
            opacity: 0.2;
            filter: grayscale(100%);
            transition: opacity 0.5s ease-in-out, filter 0.5s ease-in-out;
            cursor: grab;
        }

        body.retro-mode .bg-image {
            opacity: 1;
            filter: grayscale(0%);
            border: 2px solid #000;
            box-shadow: 4px 4px #808080;
            cursor: move;
        }

        .bg-image:hover {
            opacity: 0.8;
            filter: grayscale(0%);
        }

        .bg-image.dragging {
            cursor: grabbing;
        }

        /* New class for the temporary full-color effect */
        .full-color {
            filter: grayscale(0%);
            opacity: 1;
            transition: filter 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }

        .glass-card {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Retro-specific styles */
        .retro-card {
            background-color: #C0C0C0;
            border: 2px solid #000;
            border-top: 2px solid #fff;
            border-left: 2px solid #fff;
            box-shadow: 2px 2px #808080;
            display: none; /* Initially hidden */
        }

        body.retro-mode .retro-card {
            display: block;
        }

        body.retro-mode #modern-card {
            display: none;
        }
        
        .retro-title-bar {
            background-color: #000080;
            color: #fff;
            padding: 4px 8px;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid #000;
        }

        .retro-button {
            background-color: #C0C0C0;
            border: 2px solid #000;
            border-top: 2px solid #fff;
            border-left: 2px solid #fff;
            box-shadow: 2px 2px #808080;
            padding: 4px 8px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
        }
        
        .retro-button:active {
            box-shadow: none;
            transform: translate(2px, 2px);
            border-color: #000 #fff #fff #000;
        }
        
        /* Custom styles for floating text */
        .floating-text {
            position: absolute;
            will-change: transform;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-stone-950 to-stone-900 flex items-center justify-center min-h-screen relative text-white">

    <!-- Canvas for the retro drag line effect -->
    <canvas id="drag-canvas" class="fixed top-0 left-0 w-full h-full pointer-events-none z-10"></canvas>
    
    <div class="fixed inset-0 z-0 overflow-hidden">
        <a href="https://vgen.co/CelynIllust" target="_blank">
            <img src="https://i.postimg.cc/KvXJnb4c/Transparent-51.png" alt="animated bunny suit character" class="bg-image">
        </a>
        <a href="https://vgen.co/KarasuRoh" target="_blank">
            <img src="https://i.postimg.cc/HxhbWw8s/Goose-Gang17-Semi-Chibi-0.png" alt="animated chibi goosegang character" class="bg-image">
        </a>
        <a href="https://vgen.co/Icarus293" target="_blank">
            <img src="https://i.postimg.cc/65LLnGDz/009-Goosegang-PNG.png" alt="animated goosegang png" class="bg-image">
        </a>
        <a href="https://vgen.co/bvnny-kxn" target="_blank">
            <img src="https://i.postimg.cc/MHzXSXdK/Bvnnykxnskeb.png" alt="animated illustration" class="bg-image">
        </a>
        <a href="https://vgen.co/justfa2" target="_blank">
            <img src="https://i.postimg.cc/28RN3PDh/talk.gif" alt="animated talk gif" class="bg-image">
        </a>
        <a href="https://vgen.co/Lail0r" target="_blank">
            <img src="https://i.postimg.cc/3wWctBh3/goosegang.gif" alt="animated goosegang gif" class="bg-image">
        </a>
        <a href="https://vgen.co/RanRanVT" target="_blank">
            <img src="https://i.postimg.cc/sxKPFkPq/Untitled-249.png" alt="New GooseGang art" class="bg-image">
        </a>
        <a href="https://vgen.co/rose0famber" target="_blank">
            <img src="https://i.postimg.cc/SKrxGmmB/goose-goober.png" alt="Goose Goober" class="bg-image">
        </a>
        <a href="https://www.twitch.tv/cupvt" target="_blank">
            <img src="https://i.postimg.cc/RCjJhVhd/Goose-Um-Actually.png" alt="Goose Um Actually" class="bg-image">
        </a>
        <a href="https://vgen.co/Bztvzt" target="_blank">
            <img src="https://i.postimg.cc/8C9N4cqn/Sped-up.gif" alt="Sped up GIF" class="bg-image">
        </a>
        <a href="https://www.twitch.tv/myriadaptive" target="_blank">
            <img src="https://i.postimg.cc/bYHfDmN5/Mraid-GOose.png" alt="Myriadaptive's Image" class="bg-image">
        </a>
        <a href="https://www.twitch.tv/jonkerhimself" target="_blank">
            <img src="https://i.postimg.cc/Gt37sJX0/adasdsa.png" alt="Jonkerhimself Twitch art" class="bg-image">
        </a>
    </div>

    <!-- Modern Style Card -->
    <div id="modern-card" class="relative z-20 glass-card p-8 rounded-xl shadow-2xl text-center transform transition-transform duration-500 hover:scale-105 max-w-sm w-full mx-4">
        <img src="https://cdn.discordapp.com/attachments/1364512751933718548/1404427441598107768/idle.gif?ex=689b267b&is=6899d4fb&hm=2cdd58d8adc6568a609c2c06946d68168924c33aa0dd1a002d4010049b34043f&" alt="Animated idle goose" class="rounded-xl mb-4 max-w-xs h-auto mx-auto border-4 border-white/20">
        <div class="flex items-center justify-center space-x-2">
            <h1 class="text-4xl font-extrabold mb-2 font-serif text-white">GooseGang17</h1>
        </div>
        <div id="modern-text" class="text-xl font-bold mb-4 text-purple-400">
            <p>Check out the latest on Twitch!</p>
        </div>
        <div class="flex flex-col items-center space-y-3 mt-4">
            <a href="https://www.twitch.tv/GooseGang17" class="w-full text-white bg-purple-600 hover:bg-purple-700 font-bold py-3 px-6 rounded-lg transition-colors duration-200 shadow-md">
                Twitch Channel
            </a>
            <a href="https://www.twitch.tv/goosegang17/schedule" class="w-full text-white bg-purple-600 hover:bg-purple-700 font-bold py-3 px-6 rounded-lg transition-colors duration-200 shadow-md">
                Schedule
            </a>
            <!-- Button to toggle style -->
            <button id="toggle-style-button" onclick="toggleStyle()" class="w-full text-white bg-gray-600 hover:bg-gray-700 font-bold py-3 px-6 rounded-lg transition-colors duration-200 shadow-md">
                Retro
            </button>
        </div>
        <p class="text-gray-300 text-sm mt-4 italic">
            Click the art to see the artist
        </p>
    </div>

    <!-- Retro Style Card (Initially hidden) -->
    <div id="retro-card" class="relative z-20 retro-card p-4 mx-4 max-w-sm w-full">
        <div class="retro-title-bar mb-4">GooseGang17 - Twitch Channel</div>
        <div class="p-2">
            <img src="https://cdn.discordapp.com/attachments/1364512751933718548/1404427441598107768/idle.gif?ex=689b267b&is=6899d4fb&hm=2cdd58d8adc6568a609c2c06946d68168924c33aa0dd1a002d4010049b34043f&" alt="Animated idle goose" class="border-2 border-black mb-4 w-full mx-auto">
            <marquee behavior="scroll" direction="left" class="text-xs text-red-500 font-bold mb-2">Check out the latest on Twitch!</marquee>
            <div class="flex flex-col items-center space-y-2">
                <a href="https://www.twitch.tv/GooseGang17" target="_blank" class="w-full retro-button">
                    Twitch Channel
                </a>
                <a href="https://www.twitch.tv/goosegang17/schedule" target="_blank" class="w-full retro-button">
                    Schedule
                </a>
                <button onclick="toggleStyle()" class="w-full retro-button">
                    Modern
                </button>
            </div>
            <p class="text-xs text-center mt-4">
                Click the art to see the artist
            </p>
        </div>
    </div>

    <script type="text/javascript">
    // Global variables for the images state
    const imagesState = [];
    let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    let vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    const speeds = [1, 1.5, 2, 2.5, 3];
    const collisionRadius = 125;
    const friction = 0.99;
    const minSpeed = 0.5; // Minimum speed to ensure constant movement
    let maxSpeed;
    const dragCanvas = document.getElementById('drag-canvas');
    const ctx = dragCanvas ? dragCanvas.getContext('2d') : null; // Check if canvas exists
    let initialDragX = 0;
    let initialDragY = 0;
    const dragThreshold = 100;
    let dragLineColor = '#FF00FF';
    let isMobileDevice = false;
    let currentDragging = null;

    // This function is now in the global scope so the onclick attribute can find it
    function toggleStyle() {
        const body = document.body;
        body.classList.toggle('retro-mode');
        
        // Find both buttons and update their text
        const buttons = document.querySelectorAll('button[onclick="toggleStyle()"]');
        buttons.forEach(button => {
            if (body.classList.contains('retro-mode')) {
                button.textContent = 'Modern';
            } else {
                button.textContent = 'Retro';
            }
        });
        
        // Re-initialize images to reset their positions and speeds
        initializeImages();
    }

    // Function to detect if the device is a mobile device
    function isMobile() {
        return window.innerWidth < 768;
    }
    
    const playErrorSound = () => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
        oscillator.frequency.linearRampToValueAtTime(80, audioContext.currentTime + 0.1);

        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.5);
    };

    function getDominantColor(imgEl) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imgEl.naturalWidth;
        tempCanvas.height = imgEl.naturalHeight;
        tempCtx.drawImage(imgEl, 0, 0, tempCanvas.width, tempCanvas.height);
        const imageData = tempCtx.getImageData(
            Math.floor(tempCanvas.width / 2), 
            Math.floor(tempCanvas.height / 2), 
            1, 1
        ).data;
        return `rgb(${imageData[0]}, ${imageData[1]}, ${imageData[2]})`;
    }
    
    // This function is now in the global scope
    function initializeImages() {
        imagesState.length = 0;
        const updatedImages = document.querySelectorAll('.bg-image');
        
        maxSpeed = Math.min(vw, vh) * 0.008;

        updatedImages.forEach(image => {
            const size = image.offsetWidth;
            let x = Math.random() * (vw - size);
            let y = Math.random() * (vh - size);
            let vx = (Math.random() - 0.5) * 2 * speeds[Math.floor(Math.random() * speeds.length)];
            let vy = (Math.random() - 0.5) * 2 * speeds[Math.floor(Math.random() * speeds.length)];
            let rotation = 0;
            let vr = (Math.random() - 0.5) * 0.5;
            
            image.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;

            imagesState.push({
                element: image,
                x, y, vx, vy, size, rotation, vr,
                isDragging: false,
                startX: 0,
                startY: 0,
                lastX: x,
                lastY: y,
                lastTime: performance.now(),
                wasDragged: false,
                errorTriggered: false,
                dropTime: 0,
                bounceCount: 0 // Initialize bounce count for each image
            });
        });
    }

    function checkCollisions() {
        // This entire function is now only called on non-mobile devices
        for (let i = 0; i < imagesState.length; i++) {
            if (imagesState[i].isDragging) continue;
            for (let j = i + 1; j < imagesState.length; j++) {
                if (imagesState[j].isDragging) continue;
                
                const img1 = imagesState[i];
                const img2 = imagesState[j];

                const dx = (img1.x + img1.size / 2) - (img2.x + img2.size / 2);
                const dy = (img1.y + img1.size / 2) - (img2.y + img2.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < collisionRadius) {
                    const nx = dx / distance;
                    const ny = dy / distance;

                    const rel_vx = img1.vx - img2.vx;
                    const rel_vy = img1.vy - img2.vy;
                    
                    const dot_product = rel_vx * nx + rel_vy * ny;

                    if (dot_product < 0) {
                        const impulse = -2 * dot_product;

                        img1.vx += impulse * nx;
                        img1.vy += impulse * ny;
                        img2.vx -= impulse * nx;
                        img2.vy -= impulse * ny;

                        // Increment bounce count for both images
                        img1.bounceCount++;
                        img2.bounceCount++;

                        // Reduce slowdown on bounce
                        const slowdownFactor = 0.8;
                        if (img1.bounceCount >= 2) {
                            img1.vx *= slowdownFactor;
                            img1.vy *= slowdownFactor;
                        }
                        if (img2.bounceCount >= 2) {
                            img2.vx *= slowdownFactor;
                            img2.vy *= slowdownFactor;
                        }

                        const overlap = collisionRadius - distance;
                        const separationX = overlap * nx;
                        const separationY = overlap * ny;
                        img1.x += separationX / 2;
                        img1.y += separationY / 2;
                        img2.x -= separationX / 2;
                        img2.y -= separationY / 2;
                    }
                }
            }
        }
    }

    function gameLoop(currentTime) {
        imagesState.forEach(state => {
            if (!state.isDragging) {
                state.x += state.vx;
                state.y += state.vy;
                state.vx *= friction;
                state.vy *= friction;
                
                const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);

                // Apply speed cap only if not dragging AND 1s has passed since drop
                if (!state.isDragging && (currentTime - state.dropTime > 1000 || state.dropTime === 0)) {
                    if (speed < minSpeed) {
                        const newAngle = Math.random() * 2 * Math.PI;
                        state.vx = Math.cos(newAngle) * minSpeed;
                        state.vy = Math.sin(newAngle) * minSpeed;
                    } else if (speed > maxSpeed) {
                        const ratio = maxSpeed / speed;
                        state.vx *= ratio;
                        state.vy *= ratio;
                    }
                }
            }
            
            state.rotation += state.vr;

            const elementWidth = state.element.offsetWidth;
            const elementHeight = state.element.offsetHeight;

            const hitLeft = state.x < 0;
            const hitRight = state.x + elementWidth > vw;
            const hitTop = state.y < 0;
            const hitBottom = state.y + elementHeight > vh;
            
            if (hitLeft || hitRight) {
                state.vx = -state.vx;
                if (hitLeft) state.x = 0;
                if (hitRight) state.x = vw - elementWidth;
            }
            if (hitTop || hitBottom) {
                state.vy = -state.vy;
                if (hitTop) state.y = 0;
                if (hitBottom) state.y = vh - elementHeight;
            }
            
            state.element.style.transform = `translate(${state.x}px, ${state.y}px) rotate(${state.rotation}deg)`;
        });

        // Conditionally run collision detection for non-mobile devices
        if (!isMobileDevice) {
            checkCollisions();
        }

        requestAnimationFrame(gameLoop);
    }
    
    window.onload = function() {
        isMobileDevice = isMobile();
        dragCanvas.width = vw;
        dragCanvas.height = vh;
        initializeImages();
        requestAnimationFrame(gameLoop);
        
        window.onresize = () => {
            vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            dragCanvas.width = vw;
            dragCanvas.height = vh;
            initializeImages();
        };

        // Event listeners for dragging functionality
        document.addEventListener('mousedown', (e) => {
            const target = e.target.closest('.bg-image');
            if (target) {
                e.preventDefault();
                const state = imagesState.find(s => s.element === target);
                state.isDragging = true;
                state.wasDragged = false;
                currentDragging = state;
                target.classList.add('dragging');
                state.startX = e.clientX;
                state.startY = e.clientY;
                state.lastX = state.x;
                state.lastY = state.y;
                state.lastTime = performance.now();
                state.vx = 0;
                state.vy = 0;
                if (document.body.classList.contains('retro-mode')) {
                    initialDragX = e.clientX;
                    initialDragY = e.clientY;
                    dragLineColor = getDominantColor(target);
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (currentDragging) {
                const state = currentDragging;
                const dx = e.clientX - state.startX;
                const dy = e.clientY - state.startY;

                state.x = state.x + dx;
                state.y = state.y + dy;

                state.startX = e.clientX;
                state.startY = e.clientY;

                const timeDiff = performance.now() - state.lastTime;
                state.vx = (state.x - state.lastX) / timeDiff * 16.67;
                state.vy = (state.y - state.lastY) / timeDiff * 16.67;
                
                state.lastX = state.x;
                state.lastY = state.y;
                state.lastTime = performance.now();

                state.wasDragged = true;

                if (document.body.classList.contains('retro-mode')) {
                    const dragDistance = Math.sqrt(
                        Math.pow(e.clientX - initialDragX, 2) + 
                        Math.pow(e.clientY - initialDragY, 2)
                    );
                    
                    if (dragDistance > dragThreshold) {
                        if (!state.errorTriggered) {
                            state.errorTriggered = true;
                            playErrorSound();
                        }
                        
                        ctx.clearRect(0, 0, dragCanvas.width, dragCanvas.height);
                        ctx.beginPath();
                        ctx.moveTo(initialDragX, initialDragY);
                        ctx.lineTo(e.clientX, e.clientY);
                        ctx.strokeStyle = dragLineColor;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                    } else {
                        if (state.errorTriggered) {
                            ctx.clearRect(0, 0, dragCanvas.width, dragCanvas.height);
                        }
                        state.errorTriggered = false;
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (currentDragging) {
                currentDragging.isDragging = false;
                currentDragging.element.classList.remove('dragging');
                currentDragging.dropTime = performance.now();
                
                if (document.body.classList.contains('retro-mode')) {
                    ctx.clearRect(0, 0, dragCanvas.width, dragCanvas.height);
                    currentDragging.errorTriggered = false;
                }
                
                currentDragging = null;
            }
        });
        
        document.querySelectorAll('.bg-image').forEach(image => {
            image.parentElement.addEventListener('click', (e) => {
                const state = imagesState.find(s => s.element === image);
                if (state && state.wasDragged) {
                    e.preventDefault();
                    state.wasDragged = false;
                }
            }, true);
        });
    };
    </script>
</body>
</html>
